[
    {
        "cve": "CVE-2024-57996",
        "created_datetime": "2025-06-10T07:59:11",
        "author_id": "71851196",
        "data_id": "1932346793892737290",
        "reposts": 1,
        "post": "rt @gmdestekmerkezi: \ud83d\udce2 g\u00fcvenli\u0307k duyurusu \u2013 suse linux enterprise 15 sp6 kernel canli yamasi (cve-2024-57996)\nsuse, linux enterprise 15 sp6\u2026",
        "audience": 3699,
        "audience_total": 3699,
        "total_reposts": 1,
        "post_count": 0,
        "author": "mehmet ali demirci",
        "username": "malidemirci_gm",
        "v_score": 0.264582,
        "e_score": 0.00045,
        "base_score": "5.5",
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nNET_SCHED: SCH_SFQ: DONT ALLOW 1 PACKET LIMIT\n\nTHE CURRENT IMPLEMENTATION DOES NOT WORK CORRECTLY WITH A LIMIT OF\n1. IPROUTE2 ACTUALLY CHECKS FOR THIS AND THIS PATCH ADDS THE CHECK IN\nKERNEL AS WELL.\n\nTHIS FIXES THE FOLLOWING SYZKALLER REPORTED CRASH:\n\nUBSAN: ARRAY-INDEX-OUT-OF-BOUNDS IN NET/SCHED/SCH_SFQ.C:210:6\nINDEX 65535 IS OUT OF RANGE FOR TYPE STRUCT SFQ_HEAD[128]\nCPU: 0 PID: 2569 COMM: SYZ-EXECUTOR101 NOT TAINTED 5.10.0-SMP-DEV #1\nHARDWARE NAME: GOOGLE GOOGLE COMPUTE ENGINE/GOOGLE COMPUTE ENGINE, BIOS GOOGLE 09/13/2024\nCALL TRACE:\n  __DUMP_STACK LIB/DUMP_STACK.C:79 [INLINE]\n  DUMP_STACK+0X125/0X19F LIB/DUMP_STACK.C:120\n  UBSAN_EPILOGUE LIB/UBSAN.C:148 [INLINE]\n  __UBSAN_HANDLE_OUT_OF_BOUNDS+0XED/0X120 LIB/UBSAN.C:347\n  SFQ_LINK NET/SCHED/SCH_SFQ.C:210 [INLINE]\n  SFQ_DEC+0X528/0X600 NET/SCHED/SCH_SFQ.C:238\n  SFQ_DEQUEUE+0X39B/0X9D0 NET/SCHED/SCH_SFQ.C:500\n  SFQ_RESET+0X13/0X50 NET/SCHED/SCH_SFQ.C:525\n  QDISC_RESET+0XFE/0X510 NET/SCHED/SCH_GENERIC.C:1026\n  TBF_RESET+0X3D/0X100 NET/SCHED/SCH_TBF.C:319\n  QDISC_RESET+0XFE/0X510 NET/SCHED/SCH_GENERIC.C:1026\n  DEV_RESET_QUEUE+0X8C/0X140 NET/SCHED/SCH_GENERIC.C:1296\n  NETDEV_FOR_EACH_TX_QUEUE INCLUDE/LINUX/NETDEVICE.H:2350 [INLINE]\n  DEV_DEACTIVATE_MANY+0X6DC/0XC20 NET/SCHED/SCH_GENERIC.C:1362\n  __DEV_CLOSE_MANY+0X214/0X350 NET/CORE/DEV.C:1468\n  DEV_CLOSE_MANY+0X207/0X510 NET/CORE/DEV.C:1506\n  UNREGISTER_NETDEVICE_MANY+0X40F/0X16B0 NET/CORE/DEV.C:10738\n  UNREGISTER_NETDEVICE_QUEUE+0X2BE/0X310 NET/CORE/DEV.C:10695\n  UNREGISTER_NETDEVICE INCLUDE/LINUX/NETDEVICE.H:2893 [INLINE]\n  __TUN_DETACH+0X6B6/0X1600 DRIVERS/NET/TUN.C:689\n  TUN_DETACH DRIVERS/NET/TUN.C:705 [INLINE]\n  TUN_CHR_CLOSE+0X104/0X1B0 DRIVERS/NET/TUN.C:3640\n  __FPUT+0X203/0X840 FS/FILE_TABLE.C:280\n  TASK_WORK_RUN+0X129/0X1B0 KERNEL/TASK_WORK.C:185\n  EXIT_TASK_WORK INCLUDE/LINUX/TASK_WORK.H:33 [INLINE]\n  DO_EXIT+0X5CE/0X2200 KERNEL/EXIT.C:931\n  DO_GROUP_EXIT+0X144/0X310 KERNEL/EXIT.C:1046\n  __DO_SYS_EXIT_GROUP KERNEL/EXIT.C:1057 [INLINE]\n  __SE_SYS_EXIT_GROUP KERNEL/EXIT.C:1055 [INLINE]\n  __X64_SYS_EXIT_GROUP+0X3B/0X40 KERNEL/EXIT.C:1055\n DO_SYSCALL_64+0X6C/0XD0\n ENTRY_SYSCALL_64_AFTER_HWFRAME+0X61/0XCB\nRIP: 0033:0X7FE5E7B52479\nCODE: UNABLE TO ACCESS OPCODE BYTES AT RIP 0X7FE5E7B5244F.\nRSP: 002B:00007FFD3C800398 EFLAGS: 00000246 ORIG_RAX: 00000000000000E7\nRAX: FFFFFFFFFFFFFFDA RBX: 0000000000000000 RCX: 00007FE5E7B52479\nRDX: 000000000000003C RSI: 00000000000000E7 RDI: 0000000000000000\nRBP: 00007FE5E7BCD2D0 R08: FFFFFFFFFFFFFFB8 R09: 0000000000000014\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007FE5E7BCD2D0\nR13: 0000000000000000 R14: 00007FE5E7BCDD20 R15: 00007FE5E7B24270\n\nTHE CRASH CAN BE ALSO BE REPRODUCED WITH THE FOLLOWING (WITH A TC\nRECOMPILED TO ALLOW FOR SFQ LIMITS OF 1):\n\nTC QDISC ADD DEV DUMMY0 HANDLE 1: ROOT TBF RATE 1KBIT BURST 100B LAT 1S\n../IPROUTE2-6.9.0/TC/TC QDISC ADD DEV DUMMY0 HANDLE 2: PARENT 1:10 SFQ LIMIT 1\nIFCONFIG DUMMY0 UP\nPING -I DUMMY0 -F -C2 -W0.1 8.8.8.8\nSLEEP 1\n\nSCENARIO THAT TRIGGERS THE CRASH:\n\n* THE FIRST PACKET IS SENT AND QUEUED IN TBF AND SFQ; QDISC QLEN IS 1\n\n* TBF DEQUEUES: IT PEEKS FROM SFQ WHICH MOVES THE PACKET TO THE\n  GSO_SKB LIST AND KEEPS QDISC QLEN SET TO 1. TBF IS OUT OF TOKENS SO\n  IT SCHEDULES ITSELF FOR LATER.\n\n* THE SECOND PACKET IS SENT AND TBF TRIES TO QUEUES IT TO SFQ. QDISC\n  QLEN IS NOW 2 AND BECAUSE THE SFQ LIMIT IS 1 THE PACKET IS DROPPED\n  BY SFQ. AT THIS POINT QLEN IS 1, AND ALL OF THE SFQ SLOTS ARE EMPTY,\n  HOWEVER Q->TAIL IS NOT NULL.\n\nAT THIS POINT, ASSUMING NO MORE PACKETS ARE QUEUED, WHEN SCH_DEQUEUE\nRUNS AGAIN IT WILL DECREMENT THE QLEN FOR THE CURRENT EMPTY SLOT\nCAUSING AN UNDERFLOW AND THE SUBSEQUENT OUT OF BOUNDS ACCESS.",
        "last_modified_datetime": "2025-03-07 11:54:00",
        "published_datetime": "2025-02-27 02:15:00",
        "vendor_logo": [
            [
                "linux",
                "https://kazepublic.blob.core.windows.net/vendor-logos/data/Linux/linux.png"
            ]
        ],
        "profile_url": null,
        "feed_name": "twitter"
    }
]