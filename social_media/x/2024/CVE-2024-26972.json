[
    {
        "cve": "CVE-2024-26972",
        "created_datetime": "2024-10-16T16:31:24",
        "author_id": "317297542",
        "data_id": "1846589772426326068",
        "reposts": 0,
        "post": "sometimes you get lucky and the cve is delayed enough that the revert and potential un-revert (after some real fix) will be listed in the cve references, like https://t.co/6sfgqubthp where it claims the issue was \"fixed\" 3 times in 3 different versions of the same lts.",
        "audience": 3684,
        "audience_total": 7428,
        "total_reposts": 2,
        "post_count": 1,
        "author": "brad spengler",
        "username": "spendergrsec",
        "v_score": 0.000403038,
        "e_score": 0.00043,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nUBIFS: UBIFS_SYMLINK: FIX MEMLEAK OF INODE->I_LINK IN ERROR PATH\n\nFOR ERROR HANDLING PATH IN UBIFS_SYMLINK(), INODE WILL BE MARKED AS\nBAD FIRST, THEN IPUT() IS INVOKED. IF INODE->I_LINK IS INITIALIZED BY\nFSCRYPT_ENCRYPT_SYMLINK() IN ENCRYPTION SCENARIO, INODE->I_LINK WONT\nBE FREED BY CALLCHAIN UBIFS_FREE_INODE -> FSCRYPT_FREE_INODE IN ERROR\nHANDLING PATH, BECAUSE MAKE_BAD_INODE() HAS CHANGED INODE->I_MODE AS\nS_IFREG.\nFOLLOWING KMEMLEAK IS EASY TO BE REPRODUCED BY INJECTING ERROR IN\nUBIFS_JNL_UPDATE() WHEN DOING SYMLINK IN ENCRYPTION SCENARIO:\n UNREFERENCED OBJECT 0XFFFF888103DA3D98 (SIZE 8):\n  COMM LN, PID 1692, JIFFIES 4294914701 (AGE 12.045S)\n  BACKTRACE:\n   KMEMDUP+0X32/0X70\n   __FSCRYPT_ENCRYPT_SYMLINK+0XED/0X1C0\n   UBIFS_SYMLINK+0X210/0X300 [UBIFS]\n   VFS_SYMLINK+0X216/0X360\n   DO_SYMLINKAT+0X11A/0X190\n   DO_SYSCALL_64+0X3B/0XE0\nTHERE ARE TWO WAYS FIXING IT:\n 1. REMOVE MAKE_BAD_INODE() IN ERROR HANDLING PATH. WE CAN DO THAT\n    BECAUSE UBIFS_EVICT_INODE() WILL DO SAME PROCESSES FOR GOOD\n    SYMLINK INODE AND BAD SYMLINK INODE, FOR INODE->I_NLINK CHECKING\n    IS BEFORE IS_BAD_INODE().\n 2. FREE INODE->I_LINK BEFORE MARKING INODE BAD.\nMETHOD 2 IS PICKED, IT HAS LESS INFLUENCE, PERSONALLY, I THINK.",
        "last_modified_datetime": "2024-10-10 12:15:00",
        "published_datetime": "2024-05-01 06:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2024-26972",
        "created_datetime": "2024-10-16T14:09:28",
        "author_id": "114717065",
        "data_id": "1846554054903697685",
        "reposts": 1,
        "post": "rt @spendergrsec: no takers, so here's a full timeline of cve-2024-26972 and how the linux cna's automation produces garbage that people ac\u2026",
        "audience": 2767,
        "audience_total": 7428,
        "total_reposts": 2,
        "post_count": 1,
        "author": "pax team",
        "username": "paxteam",
        "v_score": 0.000403038,
        "e_score": 0.00043,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nUBIFS: UBIFS_SYMLINK: FIX MEMLEAK OF INODE->I_LINK IN ERROR PATH\n\nFOR ERROR HANDLING PATH IN UBIFS_SYMLINK(), INODE WILL BE MARKED AS\nBAD FIRST, THEN IPUT() IS INVOKED. IF INODE->I_LINK IS INITIALIZED BY\nFSCRYPT_ENCRYPT_SYMLINK() IN ENCRYPTION SCENARIO, INODE->I_LINK WONT\nBE FREED BY CALLCHAIN UBIFS_FREE_INODE -> FSCRYPT_FREE_INODE IN ERROR\nHANDLING PATH, BECAUSE MAKE_BAD_INODE() HAS CHANGED INODE->I_MODE AS\nS_IFREG.\nFOLLOWING KMEMLEAK IS EASY TO BE REPRODUCED BY INJECTING ERROR IN\nUBIFS_JNL_UPDATE() WHEN DOING SYMLINK IN ENCRYPTION SCENARIO:\n UNREFERENCED OBJECT 0XFFFF888103DA3D98 (SIZE 8):\n  COMM LN, PID 1692, JIFFIES 4294914701 (AGE 12.045S)\n  BACKTRACE:\n   KMEMDUP+0X32/0X70\n   __FSCRYPT_ENCRYPT_SYMLINK+0XED/0X1C0\n   UBIFS_SYMLINK+0X210/0X300 [UBIFS]\n   VFS_SYMLINK+0X216/0X360\n   DO_SYMLINKAT+0X11A/0X190\n   DO_SYSCALL_64+0X3B/0XE0\nTHERE ARE TWO WAYS FIXING IT:\n 1. REMOVE MAKE_BAD_INODE() IN ERROR HANDLING PATH. WE CAN DO THAT\n    BECAUSE UBIFS_EVICT_INODE() WILL DO SAME PROCESSES FOR GOOD\n    SYMLINK INODE AND BAD SYMLINK INODE, FOR INODE->I_NLINK CHECKING\n    IS BEFORE IS_BAD_INODE().\n 2. FREE INODE->I_LINK BEFORE MARKING INODE BAD.\nMETHOD 2 IS PICKED, IT HAS LESS INFLUENCE, PERSONALLY, I THINK.",
        "last_modified_datetime": "2024-10-10 12:15:00",
        "published_datetime": "2024-05-01 06:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2024-26972",
        "created_datetime": "2024-10-16T16:33:19",
        "author_id": "51285303",
        "data_id": "1846590256692277504",
        "reposts": 1,
        "post": "rt @spendergrsec: @wipawel's cve system today produced a dump of ~50 \"interesting\" linux kernel cves.\nwalk through cve-2024-26972 (current\u2026",
        "audience": 977,
        "audience_total": 7428,
        "total_reposts": 2,
        "post_count": 1,
        "author": "peter pwn",
        "username": "fbettag",
        "v_score": 0.000403038,
        "e_score": 0.00043,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nUBIFS: UBIFS_SYMLINK: FIX MEMLEAK OF INODE->I_LINK IN ERROR PATH\n\nFOR ERROR HANDLING PATH IN UBIFS_SYMLINK(), INODE WILL BE MARKED AS\nBAD FIRST, THEN IPUT() IS INVOKED. IF INODE->I_LINK IS INITIALIZED BY\nFSCRYPT_ENCRYPT_SYMLINK() IN ENCRYPTION SCENARIO, INODE->I_LINK WONT\nBE FREED BY CALLCHAIN UBIFS_FREE_INODE -> FSCRYPT_FREE_INODE IN ERROR\nHANDLING PATH, BECAUSE MAKE_BAD_INODE() HAS CHANGED INODE->I_MODE AS\nS_IFREG.\nFOLLOWING KMEMLEAK IS EASY TO BE REPRODUCED BY INJECTING ERROR IN\nUBIFS_JNL_UPDATE() WHEN DOING SYMLINK IN ENCRYPTION SCENARIO:\n UNREFERENCED OBJECT 0XFFFF888103DA3D98 (SIZE 8):\n  COMM LN, PID 1692, JIFFIES 4294914701 (AGE 12.045S)\n  BACKTRACE:\n   KMEMDUP+0X32/0X70\n   __FSCRYPT_ENCRYPT_SYMLINK+0XED/0X1C0\n   UBIFS_SYMLINK+0X210/0X300 [UBIFS]\n   VFS_SYMLINK+0X216/0X360\n   DO_SYMLINKAT+0X11A/0X190\n   DO_SYSCALL_64+0X3B/0XE0\nTHERE ARE TWO WAYS FIXING IT:\n 1. REMOVE MAKE_BAD_INODE() IN ERROR HANDLING PATH. WE CAN DO THAT\n    BECAUSE UBIFS_EVICT_INODE() WILL DO SAME PROCESSES FOR GOOD\n    SYMLINK INODE AND BAD SYMLINK INODE, FOR INODE->I_NLINK CHECKING\n    IS BEFORE IS_BAD_INODE().\n 2. FREE INODE->I_LINK BEFORE MARKING INODE BAD.\nMETHOD 2 IS PICKED, IT HAS LESS INFLUENCE, PERSONALLY, I THINK.",
        "last_modified_datetime": "2024-10-10 12:15:00",
        "published_datetime": "2024-05-01 06:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    }
]