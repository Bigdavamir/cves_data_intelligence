[
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-11T03:07:37",
        "author_id": "293776658",
        "data_id": "1954741464640131370",
        "reposts": 1,
        "post": "rt @flano_yuki: \u300efrom chrome renderer code exec to kernel with msg_oob\u300f\ngoogle\u306eproject zero\u30c1\u30fc\u30e0\u304c\u767a\u898b\u3057\u305flinux\u306e\u30bb\u30ad\u30e5\u30ea\u30c6\u30a3\u30d0\u30b0(cve-2025-38236)\u306e\u8a18\u4e8b\nhttps:\u2026",
        "audience": 1362,
        "audience_total": 13721,
        "total_reposts": 2,
        "post_count": 0,
        "author": "laches",
        "username": "laches1",
        "v_score": 0.000243697,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-11T08:47:56",
        "author_id": "9170162",
        "data_id": "1954827107776827850",
        "reposts": 1,
        "post": "rt @the_yellow_fall: a uaf flaw (cve-2025-38236) in the linux kernel allows for privilege escalation. a poc exploit is now public, demonstr\u2026",
        "audience": 12359,
        "audience_total": 13721,
        "total_reposts": 2,
        "post_count": 0,
        "author": "securityblog",
        "username": "securityblog",
        "v_score": 0.000243697,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-24T02:44:39",
        "author_id": "1000877131705004032",
        "data_id": "1959446727624401362",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 19,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "b",
        "username": "ziqolu",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-24T00:12:45",
        "author_id": "498631199",
        "data_id": "1959408503459815684",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 4818,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "priya joseph",
        "username": "ayirpelle",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-24T05:51:52",
        "author_id": "3242378934",
        "data_id": "1959493845218934812",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 2194,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "ethical hacker",
        "username": "offethhacker",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-25T06:25:55",
        "author_id": "15426077",
        "data_id": "1959864801179660707",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 18515,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "alex matrosov",
        "username": "matrosov",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-25T06:26:46",
        "author_id": "1410020438",
        "data_id": "1959865013939879978",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 13731,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "rehints",
        "username": "rehints",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": "https://pbs.twimg.com/profile_images/759151472772648964/--2z7-hl_normal.jpg",
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-25T06:18:08",
        "author_id": "914895373",
        "data_id": "1959862842561048592",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 18788,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "kmkz",
        "username": "kmkz_security",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    },
    {
        "cve": "CVE-2025-38236",
        "created_datetime": "2025-08-25T11:07:43",
        "author_id": "1420184215451144201",
        "data_id": "1959935715858604535",
        "reposts": 1,
        "post": "rt @linkersec: from chrome renderer code exec to kernel with msg_oob\n\njann horn @tehjh posted an article about exploiting cve-2025-38236, a\u2026",
        "audience": 71,
        "audience_total": 58136,
        "total_reposts": 7,
        "post_count": 0,
        "author": "moxifloxacin",
        "username": "obfusor",
        "v_score": 0.0367087,
        "e_score": 0.00026,
        "base_score": null,
        "description": "IN THE LINUX KERNEL, THE FOLLOWING VULNERABILITY HAS BEEN RESOLVED:\n\nAF_UNIX: DONT LEAVE CONSECUTIVE CONSUMED OOB SKBS.\n\nJANN HORN REPORTED A USE-AFTER-FREE IN UNIX_STREAM_READ_GENERIC().\n\nTHE FOLLOWING SEQUENCES REPRODUCE THE ISSUE:\n\n  $ PYTHON3\n  FROM SOCKET IMPORT *\n  S1, S2 = SOCKETPAIR(AF_UNIX, SOCK_STREAM)\n  S1.SEND(BX, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BY, MSG_OOB)\n  S2.RECV(1, MSG_OOB)     # LEAVE A CONSUMED OOB SKB\n  S1.SEND(BZ, MSG_OOB)\n  S2.RECV(1)              # RECV Z ILLEGALLY\n  S2.RECV(1, MSG_OOB)     # ACCESS Z SKB (USE-AFTER-FREE)\n\nEVEN THOUGH A USER READS OOB DATA, THE SKB HOLDING THE DATA STAYS ON\nTHE RECV QUEUE TO MARK THE OOB BOUNDARY AND BREAK THE NEXT RECV().\n\nAFTER THE LAST SEND() IN THE SCENARIO ABOVE, THE SK2S RECV QUEUE HAS\n2 LEADING CONSUMED OOB SKBS AND 1 REAL OOB SKB.\n\nTHEN, THE FOLLOWING HAPPENS DURING THE NEXT RECV() WITHOUT MSG_OOB\n\n  1. UNIX_STREAM_READ_GENERIC() PEEKS THE FIRST CONSUMED OOB SKB\n  2. MANAGE_OOB() RETURNS THE NEXT CONSUMED OOB SKB\n  3. UNIX_STREAM_READ_GENERIC() FETCHES THE NEXT NOT-YET-CONSUMED OOB SKB\n  4. UNIX_STREAM_READ_GENERIC() READS AND FREES THE OOB SKB\n\n, AND THE LAST RECV(MSG_OOB) TRIGGERS KASAN SPLAT.\n\nTHE 3. ABOVE OCCURS BECAUSE OF THE SO_PEEK_OFF CODE, WHICH DOES NOT\nEXPECT UNIX_SKB_LEN(SKB) TO BE 0, BUT THIS IS TRUE FOR SUCH CONSUMED\nOOB SKBS.\n\n  WHILE (SKIP >= UNIX_SKB_LEN(SKB)) {\n    SKIP -= UNIX_SKB_LEN(SKB);\n    SKB = SKB_PEEK_NEXT(SKB, &SK->SK_RECEIVE_QUEUE);\n    ...\n  }\n\nIN ADDITION TO THIS USE-AFTER-FREE, THERE IS ANOTHER ISSUE THAT\nIOCTL(SIOCATMARK) DOES NOT FUNCTION PROPERLY WITH CONSECUTIVE CONSUMED\nOOB SKBS.\n\nSO, NOTHING GOOD COMES OUT OF SUCH A SITUATION.\n\nINSTEAD OF COMPLICATING MANAGE_OOB(), IOCTL() HANDLING, AND THE NEXT\nECONNRESET FIX BY INTRODUCING A LOOP FOR CONSECUTIVE CONSUMED OOB SKBS,\nLETS NOT LEAVE SUCH CONSECUTIVE OOB UNNECESSARILY.\n\nNOW, WHILE RECEIVING AN OOB SKB IN UNIX_STREAM_RECV_URG(), IF ITS\nPREVIOUS SKB IS A CONSUMED OOB SKB, IT IS FREED.\n\n[0]:\nBUG: KASAN: SLAB-USE-AFTER-FREE IN UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\nREAD OF SIZE 4 AT ADDR FFFF888106EF2904 BY TASK PYTHON3/315\n\nCPU: 2 UID: 0 PID: 315 COMM: PYTHON3 NOT TAINTED 6.16.0-RC1-00407-GEC315832F6F9 #8 PREEMPT(VOLUNTARY)\nHARDWARE NAME: QEMU STANDARD PC (I440FX + PIIX, 1996), BIOS 1.16.3-4.FC42 04/01/2014\nCALL TRACE:\n <TASK>\n DUMP_STACK_LVL (LIB/DUMP_STACK.C:122)\n PRINT_REPORT (MM/KASAN/REPORT.C:409 MM/KASAN/REPORT.C:521)\n KASAN_REPORT (MM/KASAN/REPORT.C:636)\n UNIX_STREAM_READ_ACTOR (NET/UNIX/AF_UNIX.C:3027)\n UNIX_STREAM_READ_GENERIC (NET/UNIX/AF_UNIX.C:2708 NET/UNIX/AF_UNIX.C:2847)\n UNIX_STREAM_RECVMSG (NET/UNIX/AF_UNIX.C:3048)\n SOCK_RECVMSG (NET/SOCKET.C:1063 (DISCRIMINATOR 20) NET/SOCKET.C:1085 (DISCRIMINATOR 20))\n __SYS_RECVFROM (NET/SOCKET.C:2278)\n __X64_SYS_RECVFROM (NET/SOCKET.C:2291 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1) NET/SOCKET.C:2287 (DISCRIMINATOR 1))\n DO_SYSCALL_64 (ARCH/X86/ENTRY/SYSCALL_64.C:63 (DISCRIMINATOR 1) ARCH/X86/ENTRY/SYSCALL_64.C:94 (DISCRIMINATOR 1))\n ENTRY_SYSCALL_64_AFTER_HWFRAME (ARCH/X86/ENTRY/ENTRY_64.S:130)\nRIP: 0033:0X7F8911FCEA06\nCODE: 5D E8 41 8B 93 08 03 00 00 59 5E 48 83 F8 FC 75 19 83 E2 39 83 FA 08 75 11 E8 26 FF FF FF 66 0F 1F 44 00 00 48 8B 45 10 0F 05 <48> 8B 5D F8 C9 C3 0F 1F 40 00 F3 0F 1E FA 55 48 89 E5 48 83 EC 08\nRSP: 002B:00007FFFDB0DCCB0 EFLAGS: 00000202 ORIG_RAX: 000000000000002D\nRAX: FFFFFFFFFFFFFFDA RBX: 00007FFFDB0DCDC8 RCX: 00007F8911FCEA06\nRDX: 0000000000000001 RSI: 00007F8911A5E060 RDI: 0000000000000006\nRBP: 00007FFFDB0DCCD0 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000001 R11: 0000000000000202 R12: 00007F89119A7D20\nR13: FFFFFFFFC4653600 R14: 0000000000000000 R15: 0000000000000000\n </TASK>\n\nALLOCATED BY TASK 315:\n KASAN_SAVE_STACK (MM/KASAN/COMMON.C:48)\n KASAN_SAVE_TRACK (MM/KASAN/COMMON.C:60 (DISCRIMINATOR 1) MM/KASAN/COMMON.C:69 (DISCRIMINATOR 1))\n __KASAN_SLAB_ALLOC (MM/KASAN/COMMON.C:348)\n KMEM_CACHE_ALLOC_\n---TRUNCATED---",
        "last_modified_datetime": "2025-08-09 15:15:00",
        "published_datetime": "2025-07-08 08:15:00",
        "vendor_logo": null,
        "profile_url": null,
        "feed_name": "twitter"
    }
]